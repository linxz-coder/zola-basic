+++
title = "浮点型的精度探讨"
date = 2024-11-07
+++

# 什么是浮点数的精度问题？

```java
System.out.println(0.1 + 0.2); //0.30000000000000004
```

以上是一个Java代码，小数相加默认精度是不足，因为0.1和0.2被系统识别为`浮点型`。

# 浮点型的精度

任何编程语言都无法避开`浮点型精度不足`的问题。

因为浮点型本来就是为了`存储更大的数据`，而牺牲精度。

比如4位比特1010，本来最多存储$2^4$个数字（无符号数），$2^3-1$（有符号数，之所以-1，与[补码](@/blog/complement-code.md)的设计有关）。

现在，我把第一位设计成符号位，第二位设计成指数位，即$2^x$，其他位设计成正常的位数，这样就可以表示更多的数。

比如，1110代表了负数（1），指数位（$2^1$)，尾数位(二进制1.10，需要加上隐含的1在左侧）

尾数位二进制1.10转成十进制

$$ 1\times2^0+1\times2^{-1}+0\times2^2=1.5 $$

所以根据浮点数计算规则"$符号位\times指数位\times尾数位$ "，就是结果，因此1010比特的结果是-3

$$-1 \times 2^1 \times 1.5 = -3$$

可以想象，如果位数变多，为了代表尽可能多的位数，必然要舍弃一些精度，因为已经不是用数字本身来表示它自身了。

# 解决方案

浮点类型float、double的数据不适合在不容许舍入误差的金融计算领域。如果需要精确数字计算或保留指定位数的精度，Java语言可以使用`BigDecimal`类。


