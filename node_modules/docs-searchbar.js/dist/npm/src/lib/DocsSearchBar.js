"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _autocomplete = _interopRequireDefault(require("autocomplete.js"));
var _templates = _interopRequireDefault(require("./templates"));
var _utils = _interopRequireDefault(require("./utils"));
var _zepto = _interopRequireDefault(require("./zepto"));
var _meilisearch = require("meilisearch");
var _agents = require("./agents");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/**
 * Adds an autocomplete dropdown to an input field
 * @function DocsSearchBar
 * @param  {string}            options.hostUrl               URL where Meilisearch instance is hosted
 * @param  {string}            options.apiKey                Read-only API key
 * @param  {string}            options.indexUid              UID of the index to target
 * @param  {string}            [options.inputSelector]       CSS selector that targets the input
 * @param  {Element}           [options.inputElement]        Input element
 * @param  {boolean}           [options.debug]               When set to true, the dropdown will not be closed on blur
 * @param  {Object}            [options.meilisearchOptions]  Options to pass the underlying Meilisearch client
 * @param  {function}          [options.queryDataCallback]   This function will be called when querying Meilisearch
 * @param  {Object}            [options.autocompleteOptions] Options to pass to the underlying autocomplete instance
 * @param  {function}          [options.transformData]       An optional function to transform the hits
 * @param  {function}          [options.queryHook]           An optional function to transform the query
 * @param  {function}          [options.handleSelected]      This function is called when a suggestion is selected
 * @param  {function}          [options.enhancedSearchInput] When set to true, a theme is applied to the search box to improve its appearance
 * @param  {'column'|'simple'} [options.layout]              Layout of the search bar
 * @param  {boolean|'auto'}    [options.enableDarkMode]      Allows you to enforce, light theme, dark theme, or auto mode on the searchbar.
 * @return {Object}
 */
var usage = "Usage:\n  documentationSearch({\n  hostUrl,\n  apiKey,\n  indexUid,\n  [ inputSelector ],\n  [ inputElement ],\n  [ debug ],\n  [ meilisearchOptions ],\n  [ queryDataCallback ],\n  [ autocompleteOptions ],\n  [ transformData ],\n  [ queryHook ],\n  [ handleSelected ],\n  [ enhancedSearchInput ],\n  [ layout ],\n  [ enableDarkMode ]\n})";
var DocsSearchBar = /*#__PURE__*/function () {
  function DocsSearchBar(_ref) {
    var hostUrl = _ref.hostUrl,
      apiKey = _ref.apiKey,
      indexUid = _ref.indexUid,
      _ref$inputSelector = _ref.inputSelector,
      inputSelector = _ref$inputSelector === void 0 ? '' : _ref$inputSelector,
      _ref$inputElement = _ref.inputElement,
      inputElement = _ref$inputElement === void 0 ? null : _ref$inputElement,
      _ref$debug = _ref.debug,
      debug = _ref$debug === void 0 ? false : _ref$debug,
      _ref$meilisearchOptio = _ref.meilisearchOptions,
      meilisearchOptions = _ref$meilisearchOptio === void 0 ? {} : _ref$meilisearchOptio,
      _ref$queryDataCallbac = _ref.queryDataCallback,
      queryDataCallback = _ref$queryDataCallbac === void 0 ? null : _ref$queryDataCallbac,
      _ref$autocompleteOpti = _ref.autocompleteOptions,
      autocompleteOptions = _ref$autocompleteOpti === void 0 ? {} : _ref$autocompleteOpti,
      _ref$transformData = _ref.transformData,
      transformData = _ref$transformData === void 0 ? false : _ref$transformData,
      _ref$queryHook = _ref.queryHook,
      queryHook = _ref$queryHook === void 0 ? false : _ref$queryHook,
      _ref$handleSelected = _ref.handleSelected,
      handleSelected = _ref$handleSelected === void 0 ? false : _ref$handleSelected,
      _ref$enhancedSearchIn = _ref.enhancedSearchInput,
      enhancedSearchInput = _ref$enhancedSearchIn === void 0 ? false : _ref$enhancedSearchIn,
      _ref$layout = _ref.layout,
      layout = _ref$layout === void 0 ? 'columns' : _ref$layout,
      _ref$enableDarkMode = _ref.enableDarkMode,
      enableDarkMode = _ref$enableDarkMode === void 0 ? false : _ref$enableDarkMode,
      _ref$clientAgents = _ref.clientAgents,
      clientAgents = _ref$clientAgents === void 0 ? [] : _ref$clientAgents;
    _classCallCheck(this, DocsSearchBar);
    DocsSearchBar.checkArguments({
      hostUrl: hostUrl,
      apiKey: apiKey,
      indexUid: indexUid,
      inputSelector: inputSelector,
      inputElement: inputElement,
      debug: debug,
      meilisearchOptions: meilisearchOptions,
      queryDataCallback: queryDataCallback,
      autocompleteOptions: autocompleteOptions,
      transformData: transformData,
      queryHook: queryHook,
      handleSelected: handleSelected,
      enhancedSearchInput: enhancedSearchInput,
      layout: layout,
      enableDarkMode: enableDarkMode,
      clientAgents: clientAgents
    });
    this.apiKey = apiKey;
    this.hostUrl = hostUrl;
    this.indexUid = indexUid;
    this.input = inputElement ? (0, _zepto.default)(inputElement) : DocsSearchBar.getInputFromSelector(inputSelector);
    this.meilisearchOptions = _objectSpread({
      limit: 5,
      attributesToHighlight: ['*'],
      attributesToCrop: ['content'],
      cropLength: 30
    }, meilisearchOptions);
    this.queryDataCallback = queryDataCallback || null;
    this.autocompleteOptions = _objectSpread({
      debug: debug,
      hint: false,
      autoselect: true
    }, autocompleteOptions);
    var inputAriaLabel = this.input && typeof this.input.attr === 'function' && this.input.attr('aria-label');
    this.autocompleteOptions.ariaLabel = this.autocompleteOptions.ariaLabel || inputAriaLabel || 'search input';
    this.autocompleteOptions.cssClasses = this.autocompleteOptions.cssClasses || {};
    this.autocompleteOptions.cssClasses.prefix = this.autocompleteOptions.cssClasses.prefix || 'dsb';
    this.autocompleteOptions.cssClasses.root = this.autocompleteOptions.cssClasses.root || 'meilisearch-autocomplete';
    this.autocompleteOptions.keyboardShortcuts = this.parseHotkeysAutocompleteOptions(this.autocompleteOptions.keyboardShortcuts) || ['s', 191];
    this.isSimpleLayout = layout === 'simple';
    this.enableDarkMode = enableDarkMode;
    this.client = new _meilisearch.MeiliSearch({
      host: hostUrl,
      apiKey: this.apiKey,
      clientAgents: (0, _agents.constructClientAgents)(clientAgents)
    });
    DocsSearchBar.addThemeWrapper(inputElement, inputSelector, this.enableDarkMode);
    if (enhancedSearchInput) {
      this.input = DocsSearchBar.injectSearchBox(this.input);
    }
    this.autocomplete = (0, _autocomplete.default)(this.input, this.autocompleteOptions, [{
      source: this.getAutocompleteSource(transformData, queryHook),
      templates: {
        suggestion: DocsSearchBar.getSuggestionTemplate(this.isSimpleLayout),
        footer: _templates.default.footer,
        empty: DocsSearchBar.getEmptyTemplate()
      }
    }]);

    // We remove the inline styles of the wrapper element for left / right
    (0, _zepto.default)(".".concat(this.autocompleteOptions.cssClasses.root, " > [role='listbox']")).css({
      left: false,
      right: false
    });
    var customHandleSelected = handleSelected;
    this.handleSelected = customHandleSelected || this.handleSelected;

    // We prevent default link clicking if a custom handleSelected is defined
    if (customHandleSelected) {
      (0, _zepto.default)('.meilisearch-autocomplete').on('click', ".".concat(this.autocompleteOptions.cssClasses.prefix, "-suggestions a"), function (event) {
        event.preventDefault();
      });
    }
    this.autocomplete.on('autocomplete:selected', this.handleSelected.bind(null, this.autocomplete.autocomplete));
    this.autocomplete.on('autocomplete:shown', this.handleShown.bind(null, this.input));
    if (enhancedSearchInput) {
      DocsSearchBar.bindSearchBoxEvent();
    }
  }

  /**
   * Wraps input selector in a docs-searchbar-js div
   * @function addThemeWrapper
   * @param  {Element} inputElement Input Element
   * @param  {string} inputSelector Selector of the input element
   * @param  {boolean|'auto'} enableDarkMode Allows you to enforce, light theme, dark theme, or auto mode on the searchbar.
   * @returns {void}
   */
  _createClass(DocsSearchBar, [{
    key: "getAutocompleteSource",
    value:
    /**
     * Returns the `source` method to be passed to autocomplete.js. It will query
     * the Meilisearch index and call the callbacks with the formatted hits.
     * @function getAutocompleteSource
     * @param  {function} transformData An optional function to transform the hits
     * @param {function} queryHook An optional function to transform the query
     * @returns {function} Method to be passed as the `source` option of
     * autocomplete
     */
    function getAutocompleteSource(transformData, queryHook) {
      var _this = this;
      return function (query, callback) {
        if (queryHook) {
          // eslint-disable-next-line no-param-reassign
          query = queryHook(query) || query;
        }
        _this.client.index(_this.indexUid).search(query, _this.meilisearchOptions).then(function (data) {
          if (_this.queryDataCallback && typeof _this.queryDataCallback === 'function') {
            _this.queryDataCallback(data);
          }
          var hits = data.hits;
          if (transformData) {
            hits = transformData(hits) || hits;
          }
          callback(DocsSearchBar.formatHits(hits));
        });
      };
    }

    // Given a list of hits returned by the API, will reformat them to be used in
    // a template
  }, {
    key: "handleSelected",
    value: function handleSelected(input, event, suggestion, datasetNumber) {
      var context = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      // Do nothing if click on the suggestion, as it's already a <a href>, the
      // browser will take care of it. This allow Ctrl-Clicking on results and not
      // having the main window being redirected as well
      if (context.selectionMethod === 'click') {
        return;
      }
      input.setVal('');
      window.location.assign(suggestion.url);
    }
  }, {
    key: "handleShown",
    value: function handleShown(input) {
      var middleOfInput = input.offset().left + input.width() / 2;
      var middleOfWindow = (0, _zepto.default)(document).width() / 2;
      if (isNaN(middleOfWindow)) {
        middleOfWindow = 900;
      }
      var alignClass = middleOfInput - middleOfWindow >= 0 ? 'meilisearch-autocomplete-right' : 'meilisearch-autocomplete-left';
      var otherAlignClass = middleOfInput - middleOfWindow < 0 ? 'meilisearch-autocomplete-right' : 'meilisearch-autocomplete-left';
      var autocompleteWrapper = (0, _zepto.default)('.meilisearch-autocomplete');
      if (!autocompleteWrapper.hasClass(alignClass)) {
        autocompleteWrapper.addClass(alignClass);
      }
      if (autocompleteWrapper.hasClass(otherAlignClass)) {
        autocompleteWrapper.removeClass(otherAlignClass);
      }
    }
  }, {
    key: "parseHotkeysAutocompleteOptions",
    value: function parseHotkeysAutocompleteOptions(hotkeys) {
      if (hotkeys === undefined || hotkeys === null) {
        return null;
      }
      return hotkeys.map(function (item) {
        return item === '/' ? 191 : item;
      });
    }
  }], [{
    key: "addThemeWrapper",
    value: function addThemeWrapper(inputElement, inputSelector, enableDarkMode) {
      var input = inputElement || document.querySelector(inputSelector);
      var parent = input.parentNode;
      var wrapper = document.createElement('div');
      wrapper.className += 'docs-searchbar-js';
      parent.replaceChild(wrapper, input);
      wrapper.appendChild(input);
      var isSystemInDarkMode = Boolean(enableDarkMode);
      if (enableDarkMode === 'auto' && window.matchMedia) {
        var mediaQueryList = window.matchMedia('(prefers-color-scheme: dark)');
        isSystemInDarkMode = mediaQueryList.matches;
        var listener = function listener(e) {
          if (document.body.contains(wrapper)) {
            wrapper.setAttribute('data-ds-theme', e.matches ? 'dark' : 'light');
          } else if (mediaQueryList.removeEventListener) {
            mediaQueryList.removeEventListener('change', listener);
          } else if (mediaQueryList.removeListener) {
            mediaQueryList.removeListener(listener);
          }
        };
        if (mediaQueryList.addEventListener) {
          mediaQueryList.addEventListener('change', listener);
        } else if (mediaQueryList.addListener) {
          mediaQueryList.addListener(listener);
        }
      }
      wrapper.setAttribute('data-ds-theme', isSystemInDarkMode ? 'dark' : 'light');
    }

    /**
     * Checks that the passed arguments are valid. Will throw errors otherwise
     * @function checkArguments
     * @param  {object} args Arguments as an option object
     * @returns {void}
     */
  }, {
    key: "checkArguments",
    value: function checkArguments(args) {
      if (!args.inputSelector && !args.inputElement || !args.indexUid || !args.hostUrl) {
        throw new Error(usage);
      }
      if (args.inputSelector !== null && typeof args.inputSelector !== 'string') {
        throw new Error("Error: inputSelector:".concat(args.inputSelector, "  must be a string. Each selector must match only one element and separated by ','"));
      }
      if (!args.inputElement && !DocsSearchBar.getInputFromSelector(args.inputSelector)) {
        throw new Error("Error: No input element in the page matches ".concat(args.inputSelector));
      }
      DocsSearchBar.typeCheck(args, ['meilisearchOptions', 'autocompleteOptions'], 'object', true);
      if (args.enableDarkMode !== 'auto' && args.enableDarkMode !== false && args.enableDarkMode !== true) {
        throw new Error("Error: \"enableDarkMode\" must be either true, false, or 'auto'. Supplied value: ".concat(args.enableDarkMode));
      }
      DocsSearchBar.typeCheck(args, ['debug', 'enhancedSearchInput'], 'boolean', false);
      DocsSearchBar.typeCheck(args, ['clientAgents'], 'array', true);
      DocsSearchBar.typeCheck(args, ['queryDataCallback', 'transformData', 'queryHook', 'handleSelected'], 'function', true);
      if (args.layout && !['simple', 'columns'].includes(args.layout)) {
        throw new Error("Error: \"layout\" must be either 'columns' or 'simple'. Supplied value: ".concat(args.layout));
      }
    }
    /**
     * Throw a type error.
     *
     * @param  {string} argument - Name of the parameter
     * @param  {string} type - Type the parameter should have
     * @param  {string} value - Value the parameter has
     *
     * @returns {void}
     */
  }, {
    key: "throwTypeError",
    value: function throwTypeError(argument, type, value) {
      throw new Error("Error: \"".concat(argument, "\" must be of type: ").concat(type, ". Found type: ").concat(_typeof(value)));
    }

    /**
     * Checks if the arguments defined in the check variable are of the supplied
     * type
     * @param {any[]} args all arguments
     * @param {string[]} checkArguments array with the argument names to check
     * @param {string} type required type for the arguments
     * @param {boolean} optional don't check argument if it's falsy
     * @returns {void}
     */
  }, {
    key: "typeCheck",
    value: function typeCheck(args, checkArguments, type, optional) {
      checkArguments.filter(function (argument) {
        return !optional || args[argument];
      }).forEach(function (argument) {
        var value = args[argument];
        if (type === 'array') {
          if (!Array.isArray(args[argument])) {
            DocsSearchBar.throwTypeError(argument, type, value);
          }
        } else if (_typeof(args[argument]) !== type) {
          DocsSearchBar.throwTypeError(argument, type, value);
        }
      });
    }
  }, {
    key: "injectSearchBox",
    value: function injectSearchBox(input) {
      input.before(_templates.default.searchBox);
      var newInput = input.prev().prev().find('input');
      input.remove();
      return newInput;
    }
  }, {
    key: "bindSearchBoxEvent",
    value: function bindSearchBoxEvent() {
      (0, _zepto.default)('.searchbox [type="reset"]').on('click', function () {
        (0, _zepto.default)('input#docs-searchbar').focus();
        (0, _zepto.default)(this).addClass('hide');
        _autocomplete.default.autocomplete.setVal('');
      });
      (0, _zepto.default)('input#docs-searchbar').on('keyup', function () {
        var searchbox = document.querySelector('input#docs-searchbar');
        var reset = document.querySelector('.searchbox [type="reset"]');
        reset.className = 'searchbox__reset';
        if (searchbox.value.length === 0) {
          reset.className += ' hide';
        }
      });
    }

    /**
     * Returns the matching input from a CSS selector, null if none matches
     * @function getInputFromSelector
     * @param  {string} selector CSS selector that matches the search
     * input of the page
     * @returns {zepto.Z|null} Matching input or null
     */
  }, {
    key: "getInputFromSelector",
    value: function getInputFromSelector(selector) {
      var input = (0, _zepto.default)(selector).filter('input');
      return input.length ? (0, _zepto.default)(input[0]) : null;
    }
  }, {
    key: "formatHits",
    value: function formatHits(receivedHits) {
      var clonedHits = _utils.default.deepClone(receivedHits);
      var hits = clonedHits.map(function (hit) {
        if (hit._formatted) {
          var cleanFormatted = _utils.default.replaceNullString(hit._formatted);
          // eslint-disable-next-line no-param-reassign
          hit._formatted = _utils.default.renameKeysWithLevels(cleanFormatted, 'hierarchy_');
        }
        var cleanHit = _utils.default.replaceNullString(hit);
        return _utils.default.renameKeysWithLevels(cleanHit, 'hierarchy_');
      });

      // Group hits by category / subcategory
      var groupedHits = _utils.default.groupBy(hits, 'lvl0');
      _zepto.default.each(groupedHits, function (level, collection) {
        var groupedHitsByLvl1 = _utils.default.groupBy(collection, 'lvl1');
        var flattenedHits = _utils.default.flattenAndFlagFirst(groupedHitsByLvl1, 'isSubCategoryHeader');
        groupedHits[level] = flattenedHits;
      });
      groupedHits = _utils.default.flattenAndFlagFirst(groupedHits, 'isCategoryHeader');
      // Translate hits into smaller objects to be send to the template
      return groupedHits.map(function (hit) {
        var url = DocsSearchBar.formatURL(hit);
        var category = _utils.default.getHighlightedValue(hit, 'lvl0');
        var subcategory = _utils.default.getHighlightedValue(hit, 'lvl1') || category;
        var displayTitle = _utils.default.compact([_utils.default.getHighlightedValue(hit, 'lvl2') || subcategory, _utils.default.getHighlightedValue(hit, 'lvl3'), _utils.default.getHighlightedValue(hit, 'lvl4'), _utils.default.getHighlightedValue(hit, 'lvl5'), _utils.default.getHighlightedValue(hit, 'lvl6')]).join('<span class="aa-suggestion-title-separator" aria-hidden="true"> › </span>');
        var text = _utils.default.getSnippetedValue(hit, 'content');
        var isTextOrSubcategoryNonEmpty = subcategory && subcategory !== '' || displayTitle && displayTitle !== '';
        var isLvl1EmptyOrDuplicate = !subcategory || subcategory === '' || subcategory === category;
        var isLvl2 = displayTitle && displayTitle !== '' && displayTitle !== subcategory;
        var isLvl1 = !isLvl2 && subcategory && subcategory !== '' && subcategory !== category;
        var isLvl0 = !isLvl1 && !isLvl2;
        return {
          isLvl0: isLvl0,
          isLvl1: isLvl1,
          isLvl2: isLvl2,
          isLvl1EmptyOrDuplicate: isLvl1EmptyOrDuplicate,
          isCategoryHeader: hit.isCategoryHeader,
          isSubCategoryHeader: hit.isSubCategoryHeader,
          isTextOrSubcategoryNonEmpty: isTextOrSubcategoryNonEmpty,
          category: category,
          subcategory: subcategory,
          title: displayTitle,
          text: text,
          url: url
        };
      });
    }
  }, {
    key: "formatURL",
    value: function formatURL(hit) {
      var url = hit.url,
        anchor = hit.anchor;
      if (url) {
        var containsAnchor = url.indexOf('#') !== -1;
        if (containsAnchor) return url;else if (anchor) return "".concat(hit.url, "#").concat(hit.anchor);
        return url;
      } else if (anchor) return "#".concat(hit.anchor);
      console.warn('no anchor nor url for : ', JSON.stringify(hit));
      return null;
    }
  }, {
    key: "getEmptyTemplate",
    value: function getEmptyTemplate() {
      return _templates.default.empty;
    }
  }, {
    key: "getSuggestionTemplate",
    value: function getSuggestionTemplate(isSimpleLayout) {
      return isSimpleLayout ? _templates.default.suggestionSimple : _templates.default.suggestion;
    }
  }]);
  return DocsSearchBar;
}();
var _default = DocsSearchBar;
exports.default = _default;