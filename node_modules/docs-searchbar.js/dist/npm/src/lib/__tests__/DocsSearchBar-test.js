"use strict";

var _sinon = _interopRequireDefault(require("sinon"));
var _zepto = _interopRequireDefault(require("../zepto"));
var _DocsSearchBar = _interopRequireDefault(require("../DocsSearchBar"));
var _version = _interopRequireDefault(require("../version"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
/**
 * Pitfalls:
 * Whenever you call new DocsSearchBar(), it will add the a new dropdown markup to
 * the page. Because we are clearing the document.body.innerHTML between each
 * test, it usually is not a problem.
 * Except that autocomplete.js remembers internally how many times it has been
 * called, and adds this number to classes of elements it creates.
 * DO NOT rely on any .dsb-dataset-X, .dsb-suggestions-X, etc classes where X is
 * a number. This will change if you add or remove tests and will break your
 * tests.
 **/

describe('DocsSearchBar', function () {
  beforeEach(function () {
    // Note: If you edit this HTML while doing TDD with `npm run test:watch`,
    // you will have to restart `npm run test:watch` for the new HTML to be
    // updated
    document.body.innerHTML = "\n    <div>\n      <input id=\"input\" name=\"search\" />\n      <span class=\"i-am-a-span\">span span</span>\n    </div>\n    ";

    // We prevent the logging of expected errors
    window.console.warn = _sinon.default.spy();
    Object.defineProperty(window, 'location', {
      writable: true,
      value: {
        assign: jest.fn()
      }
    });
  });
  describe('constructor', function () {
    var MeiliSearch;
    var meilisearch;
    var AutoComplete;
    var autocomplete;
    var defaultOptions;
    beforeEach(function () {
      meilisearch = {
        meilisearch: 'client'
      };
      MeiliSearch = _sinon.default.stub().returns(meilisearch);
      autocomplete = {
        on: _sinon.default.spy()
      };
      AutoComplete = _sinon.default.stub().returns(autocomplete);
      defaultOptions = {
        hostUrl: 'https://test.getmeili.com',
        apiKey: 'apiKey',
        indexUid: 'indexUID',
        inputSelector: '#input'
      };
      _sinon.default.spy(_DocsSearchBar.default, 'checkArguments');
      _sinon.default.stub(_DocsSearchBar.default, 'getInputFromSelector').returns(true);
      _DocsSearchBar.default.__Rewire__('MeiliSearch', MeiliSearch);
      _DocsSearchBar.default.__Rewire__('autocomplete', AutoComplete);
    });
    afterEach(function () {
      _DocsSearchBar.default.checkArguments.restore();
      _DocsSearchBar.default.getInputFromSelector.restore();
      _DocsSearchBar.default.__ResetDependency__('meilisearch');
      _DocsSearchBar.default.__ResetDependency__('autocomplete');
    });
    it('should call checkArguments', function () {
      // Given
      var options = defaultOptions;

      // When
      new _DocsSearchBar.default(options);

      // Then
      expect(_DocsSearchBar.default.checkArguments.calledOnce).toBe(true);
    });
    it('should pass main options as instance properties', function () {
      // Given
      var options = defaultOptions;

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      expect(actual.hostUrl).toEqual('https://test.getmeili.com');
      expect(actual.indexUid).toEqual('indexUID');
      expect(actual.apiKey).toEqual('apiKey');
    });
    it('should allow customize meilisearchOptions without loosing default options', function () {
      // Given
      var options = _objectSpread({
        meilisearchOptions: {
          cropLength: 50
        }
      }, defaultOptions);

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      expect(actual.meilisearchOptions).toEqual({
        limit: 5,
        attributesToCrop: ['content'],
        attributesToHighlight: ['*'],
        cropLength: 50
      });
    });
    it('should allow customize limit', function () {
      // Given
      var options = _objectSpread({
        meilisearchOptions: {
          limit: 10
        }
      }, defaultOptions);

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      expect(actual.meilisearchOptions).toEqual({
        limit: 10,
        attributesToHighlight: ['*'],
        attributesToCrop: ['content'],
        cropLength: 30
      });
    });
    it('should pass the input element as an instance property', function () {
      // Given
      var options = defaultOptions;
      _DocsSearchBar.default.getInputFromSelector.returns((0, _zepto.default)('<span>foo</span>'));

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      var $inputs = actual.input;
      expect($inputs.text()).toEqual('foo');
      expect($inputs[0].tagName).toEqual('SPAN');
    });
    it('should pass secondary options as instance properties', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        meilisearchOptions: {
          anOption: 42
        },
        autocompleteOptions: {
          anOption: 44
        }
      });

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      expect(_typeof(actual.meilisearchOptions)).toEqual('object');
      expect(actual.meilisearchOptions.anOption).toEqual(42);
      expect(actual.autocompleteOptions).toEqual({
        debug: false,
        hint: false,
        autoselect: true,
        cssClasses: {
          root: 'meilisearch-autocomplete',
          prefix: 'dsb'
        },
        anOption: 44,
        ariaLabel: 'search input',
        keyboardShortcuts: ['s', 191]
      });
    });
    it('should instantiate meilisearch with the correct values', function () {
      // Given
      var options = defaultOptions;

      // When
      new _DocsSearchBar.default(options);

      // Then
      expect(MeiliSearch.calledOnce).toBe(true);
      expect(MeiliSearch.calledWith({
        host: 'https://test.getmeili.com',
        apiKey: 'apiKey',
        clientAgents: ["Meilisearch docs-searchbar.js (v".concat(_version.default, ")")]
      })).toBe(true);
    });
    it('should instantiate autocomplete.js', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        autocompleteOptions: {
          anOption: '44'
        }
      });
      var $input = (0, _zepto.default)('<input name="foo" />');
      _DocsSearchBar.default.getInputFromSelector.returns($input);

      // When
      new _DocsSearchBar.default(options);

      // Then
      expect(AutoComplete.calledOnce).toBe(true);
      expect(AutoComplete.calledWith($input, {
        anOption: '44',
        cssClasses: {
          root: 'meilisearch-autocomplete',
          prefix: 'dsb'
        },
        debug: false,
        hint: false,
        autoselect: true,
        ariaLabel: 'search input',
        keyboardShortcuts: ['s', 191]
      })).toBe(true);
    });
    it('should listen to the selected and shown event of autocomplete', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        handleSelected: function handleSelected() {}
      });

      // When
      new _DocsSearchBar.default(options);

      // Then
      expect(autocomplete.on.calledTwice).toBe(true);
      expect(autocomplete.on.calledWith('autocomplete:selected')).toBe(true);
    });
    it('should have spread the user agents', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        clientAgents: ['test']
      });

      // When
      new _DocsSearchBar.default(options);

      // Then
      expect(MeiliSearch.calledOnce).toBe(true);
      expect(MeiliSearch.calledWith({
        host: 'https://test.getmeili.com',
        apiKey: 'apiKey',
        clientAgents: ['test', "Meilisearch docs-searchbar.js (v".concat(_version.default, ")")]
      })).toBe(true);
    });
    it('should accept the input element directly', function () {
      var inputElement = document.getElementById('input');
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        inputElement: inputElement
      });
      delete options.inputSelector;

      // When
      var actual = new _DocsSearchBar.default(options);

      // Then
      var $inputs = actual.input;
      expect($inputs[0]).toEqual(inputElement);
    });
  });
  describe('checkArguments', function () {
    var checkArguments;
    var defaultOptions;
    beforeEach(function () {
      checkArguments = _DocsSearchBar.default.checkArguments;
      defaultOptions = {
        hostUrl: 'https://test.getmeili.com',
        apiKey: 'apiKey',
        indexUid: 'indexUID',
        inputSelector: '#input',
        debug: false,
        meilisearchOptions: {},
        queryDataCallback: null,
        autocompleteOptions: {},
        transformData: false,
        queryHook: false,
        handleSelected: false,
        enhancedSearchInput: false,
        layout: 'columns',
        enableDarkMode: false
      };
    });
    afterEach(function () {
      if (_DocsSearchBar.default.getInputFromSelector.restore) {
        _DocsSearchBar.default.getInputFromSelector.restore();
      }
    });
    it('should throw an error if no hostUrl defined', function () {
      // Given
      var options = defaultOptions;
      delete options.hostUrl;

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Usage:/);
    });
    it('should throw an error if no inputSelector or inputElement defined', function () {
      // Given
      var options = defaultOptions;
      delete options.inputSelector;

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Usage:/);
    });
    it('should throw an error if no indexUid defined', function () {
      // Given
      var options = defaultOptions;
      delete options.indexUid;

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Usage:/);
    });
    it('should throw an error if no selector matches', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        inputSelector: '#'
      });
      _sinon.default.stub(_DocsSearchBar.default, 'getInputFromSelector').returns(false);

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if enableDarkMode is not a boolean', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        enableDarkMode: 'yes'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if debug is not a boolean', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        debug: null
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if enhancedSearchInput is not a boolean', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        enhancedSearchInput: 'yes'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if meilisearchOptions is not an object', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        meilisearchOptions: 'not-an-object'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if autocompleteOptions is not a object', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        autocompleteOptions: 'not-an-object'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if queryDataCallback is not a function', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        queryDataCallback: 'not-a-function'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if transformData is not a function', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        transformData: 'not-a-function'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if queryHook is not a function', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        queryHook: 'not-a-function'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if handleSelected is not a function', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        handleSelected: 'not-a-function'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
    it('should throw an error if clientAgents is not an array', function () {
      // Given
      var options = _objectSpread(_objectSpread({}, defaultOptions), {}, {
        clientAgents: 'test'
      });

      // When
      expect(function () {
        checkArguments(options);
      }).toThrow(/^Error:/);
    });
  });
  describe('getInputFromSelector', function () {
    var getInputFromSelector;
    beforeEach(function () {
      getInputFromSelector = _DocsSearchBar.default.getInputFromSelector;
    });
    it('should return null if no element matches the selector', function () {
      // Given
      var selector = '.i-do-not-exist > at #all';

      // When
      var actual = getInputFromSelector(selector);

      // Then
      expect(actual).toEqual(null);
    });
    it('should return null if the matched element is not an input', function () {
      // Given
      var selector = '.i-am-a-span';

      // When
      var actual = getInputFromSelector(selector);

      // Then
      expect(actual).toEqual(null);
    });
    it('should return a Zepto wrapped element if it matches', function () {
      // Given
      var selector = '#input';

      // When
      var actual = getInputFromSelector(selector);

      // Then
      expect(_zepto.default.zepto.isZ(actual)).toBe(true);
    });
  });
  describe('getAutocompleteSource', function () {
    var client;
    var MeiliSearch;
    var docsSearchBar;
    beforeEach(function () {
      client = {
        meilisearch: 'client',
        index: _sinon.default.stub().returns({
          search: _sinon.default.stub().returns({
            then: _sinon.default.spy()
          })
        })
      };
      MeiliSearch = _sinon.default.stub().returns(client);
      _DocsSearchBar.default.__Rewire__('MeiliSearch', MeiliSearch);
      docsSearchBar = new _DocsSearchBar.default({
        hostUrl: 'https://test.getmeili.com',
        indexUid: 'indexUID',
        apiKey: 'apiKey',
        inputSelector: '#input'
      });
    });
    afterEach(function () {
      _DocsSearchBar.default.__ResetDependency__('meilisearch');
    });
    it('returns a function', function () {
      // Given
      var actual = docsSearchBar.getAutocompleteSource();

      // When

      // Then
      expect(actual).toBeInstanceOf(Function);
    });
    describe('the returned function', function () {
      it('calls the Meilisearch client with the correct parameters', function () {
        // Given
        var actual = docsSearchBar.getAutocompleteSource();

        // When
        actual('query');

        // Then
        expect(client.index.calledOnce).toBe(true);
        expect(client.index('indexUID').search.calledOnce).toBe(true);
        var expectedParams = {
          limit: 5,
          attributesToHighlight: ['*'],
          attributesToCrop: ['content'],
          cropLength: 30
        };
        expect(client.index.calledWith('indexUID')).toBe(true);
        expect(client.index('indexUid').search.calledWith('query', expectedParams)).toBe(true);
      });
    });
    describe('when queryHook is used', function () {
      it('calls the Meilisearch client with the correct parameters', function () {
        // Given
        var actual = docsSearchBar.getAutocompleteSource(false, function (query) {
          return "".concat(query, " modified");
        });

        // When
        actual('query');

        // Then
        expect(client.index.calledOnce).toBe(true);
        expect(client.index('indexUID').search.calledOnce).toBe(true);
        var expectedParams = {
          limit: 5,
          attributesToHighlight: ['*'],
          attributesToCrop: ['content'],
          cropLength: 30
        };
        expect(client.index('indexUID').search.calledWith('query modified', expectedParams)).toBe(true);
        expect(client.index.calledWith('indexUID')).toBe(true);
      });
    });
  });
  describe('handleSelected', function () {
    it('should change the location if no handleSelected specified', function () {
      // Given
      var options = {
        hostUrl: 'test.com',
        apiKey: 'key',
        indexUid: 'foo',
        inputSelector: '#input'
      };

      // When
      var dsb = new _DocsSearchBar.default(options);
      dsb.autocomplete.trigger('autocomplete:selected', {
        url: 'https://website.com/doc/page'
      });
      return new Promise(function (resolve) {
        expect(window.location.assign).toHaveBeenCalledWith('https://website.com/doc/page');
        resolve();
      });
    });
    it('should call the custom handleSelected if defined', function () {
      // Given
      var customHandleSelected = jest.fn();
      var options = {
        hostUrl: 'test.com',
        apiKey: 'key',
        indexUid: 'foo',
        inputSelector: '#input',
        handleSelected: customHandleSelected
      };
      var expectedInput = expect.objectContaining({
        open: expect.any(Function)
      });
      var expectedEvent = expect.objectContaining({
        type: 'autocomplete:selected'
      });
      var expectedSuggestion = expect.objectContaining({
        url: 'https://website.com/doc/page'
      });

      // When
      var dsb = new _DocsSearchBar.default(options);
      dsb.autocomplete.trigger('autocomplete:selected', {
        url: 'https://website.com/doc/page'
      });
      return new Promise(function (resolve) {
        expect(customHandleSelected).toHaveBeenCalledWith(expectedInput, expectedEvent, expectedSuggestion);
        resolve();
      });
    });
    it('should prevent all clicks on links if a custom handleSelected is specified', function () {
      // Given
      var options = {
        hostUrl: 'test.com',
        apiKey: 'key',
        indexUid: 'foo',
        inputSelector: '#input',
        handleSelected: jest.fn()
      };

      // Building a dropdown with links inside
      var dsb = new _DocsSearchBar.default(options);
      dsb.autocomplete.trigger('autocomplete:shown');
      var dataset = (0, _zepto.default)('.meilisearch-autocomplete');
      var suggestions = (0, _zepto.default)('<div class="dsb-suggestions"></div>');
      var testLink = (0, _zepto.default)('<a href="#">test link</a>');
      dataset.append(suggestions);
      suggestions.append(testLink);

      // Simulating a click on the link
      var clickEvent = new _zepto.default.Event('click');
      clickEvent.preventDefault = jest.fn();
      testLink.trigger(clickEvent);
      return new Promise(function (resolve) {
        expect(clickEvent.preventDefault).toHaveBeenCalled();
        resolve();
      });
    });
    describe('default handleSelected', function () {
      it('enterKey: should change the page', function () {
        var options = {
          hostUrl: 'test.com',
          apiKey: 'key',
          indexUid: 'foo',
          inputSelector: '#input'
        };
        var mockSetVal = jest.fn();
        var mockInput = {
          setVal: mockSetVal
        };
        var mockSuggestion = {
          url: 'www.example.com'
        };
        var mockContext = {
          selectionMethod: 'enterKey'
        };
        new _DocsSearchBar.default(options).handleSelected(mockInput, undefined,
        // Event
        mockSuggestion, undefined,
        // Dataset
        mockContext);
        return new Promise(function (resolve) {
          expect(mockSetVal).toHaveBeenCalledWith('');
          expect(window.location.assign).toHaveBeenCalledWith('www.example.com');
          resolve();
        });
      });
      it('click: should not change the page', function () {
        var options = {
          hostUrl: 'test.com',
          apiKey: 'key',
          indexUid: 'foo',
          inputSelector: '#input'
        };
        var mockSetVal = jest.fn();
        var mockInput = {
          setVal: mockSetVal
        };
        var mockContext = {
          selectionMethod: 'click'
        };
        new _DocsSearchBar.default(options).handleSelected(mockInput, undefined,
        // Event
        undefined,
        // Suggestion
        undefined,
        // Dataset
        mockContext);
        return new Promise(function (resolve) {
          expect(mockSetVal).not.toHaveBeenCalled();
          expect(window.location.assign).not.toHaveBeenCalled();
          resolve();
        });
      });
    });
  });
  describe('handleShown', function () {
    it('should add an alignment class', function () {
      // Given
      var options = {
        hostUrl: 'test.com',
        apiKey: 'key',
        indexUid: 'foo',
        inputSelector: '#input'
      };

      // When
      var dsb = new _DocsSearchBar.default(options);
      dsb.autocomplete.trigger('autocomplete:shown');
      expect((0, _zepto.default)('.meilisearch-autocomplete').attr('class')).toEqual('meilisearch-autocomplete meilisearch-autocomplete-right');
    });
  });
  describe('formatHits', function () {
    it('should not mutate the input', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(input).not.toBe(actual);
    });
    it('should set category headers to the first of each category', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'Geo-search',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Python',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].isCategoryHeader).toEqual(true);
      expect(actual[2].isCategoryHeader).toEqual(true);
    });
    it('should group items of same category together', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Python',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'Geo-search',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].category).toEqual('Ruby');
      expect(actual[1].category).toEqual('Ruby');
      expect(actual[2].category).toEqual('Python');
    });
    it('should mark all first elements as subcategories', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Python',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'Geo-search',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].isSubCategoryHeader).toEqual(true);
      expect(actual[2].isSubCategoryHeader).toEqual(true);
    });
    it('should mark new subcategories as such', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Foo',
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Python',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Bar',
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }, {
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'Geo-search',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].isSubCategoryHeader).toEqual(true);
      expect(actual[1].isSubCategoryHeader).toEqual(false);
      expect(actual[2].isSubCategoryHeader).toEqual(true);
      expect(actual[3].isSubCategoryHeader).toEqual(true);
    });
    it('should use highlighted category and subcategory if exists', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Foo',
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        _formatted: {
          hierarchy_lvl0: '<mark>Ruby</mark>',
          hierarchy_lvl1: '<mark>API</mark>'
        }
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].category).toEqual('<mark>Ruby</mark>');
      expect(actual[0].subcategory).toEqual('<mark>API</mark>');
    });
    it('should use lvl2 as title', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Foo',
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].title).toEqual('Foo');
    });
    it('should use lvl1 as title if no lvl2', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].title).toEqual('API');
    });
    it('should use lvl0 as title if no lvl2 nor lvl2', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: null,
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].title).toEqual('Ruby');
    });
    it('should concatenate lvl2+ for title if more', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Geo-search',
        hierarchy_lvl3: 'Foo',
        hierarchy_lvl4: 'Bar',
        hierarchy_lvl5: 'Baz'
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);
      var separator = '<span class="aa-suggestion-title-separator" aria-hidden="true"> › </span>';
      // Then
      expect(actual[0].title).toEqual("Geo-search".concat(separator, "Foo").concat(separator, "Bar").concat(separator, "Baz"));
    });
    it('should concatenate highlighted elements', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: 'Geo-search',
        hierarchy_lvl3: 'Foo',
        hierarchy_lvl4: 'Bar',
        hierarchy_lvl5: 'Baz',
        _formatted: {
          hierarchy_lvl0: '<mark>Ruby</mark>',
          hierarchy_lvl1: '<mark>API</mark>',
          hierarchy_lvl2: '<mark>Geo-search</mark>',
          hierarchy_lvl3: '<mark>Foo</mark>',
          hierarchy_lvl4: '<mark>Bar</mark>',
          hierarchy_lvl5: '<mark>Baz</mark>'
        }
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);
      var separator = '<span class="aa-suggestion-title-separator" aria-hidden="true"> › </span>';
      // Then
      var expected = "<mark>Geo-search</mark>".concat(separator, "<mark>Foo</mark>").concat(separator, "<mark>Bar</mark>").concat(separator, "<mark>Baz</mark>");
      expect(actual[0].title).toEqual(expected);
    });
    it('should add ellipsis to content', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        content: 'foo bar',
        _formatted: {
          content: 'lorem <mark>foo</mark> bar ipsum.'
        }
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].text).toEqual('…lorem <mark>foo</mark> bar ipsum.');
    });
    it('should add the anchor to the url if one is set', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        content: 'foo bar',
        url: 'http://foo.bar/',
        anchor: 'anchor'
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].url).toEqual('http://foo.bar/#anchor');
    });
    it('should not add the anchor to the url if one is set but it is already in the URL', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        content: 'foo bar',
        url: 'http://foo.bar/#anchor',
        anchor: 'anchor'
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].url).toEqual('http://foo.bar/#anchor');
    });
    it('should just use the URL if no anchor is provided', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        content: 'foo bar',
        url: 'http://foo.bar/'
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].url).toEqual(input[0].url);
    });
    it('should return the anchor if there is no URL', function () {
      // Given
      var input = [{
        hierarchy_lvl0: 'Ruby',
        hierarchy_lvl1: 'API',
        hierarchy_lvl2: null,
        hierarchy_lvl3: null,
        hierarchy_lvl4: null,
        hierarchy_lvl5: null,
        content: 'foo bar',
        anchor: 'anchor'
      }];

      // When
      var actual = _DocsSearchBar.default.formatHits(input);

      // Then
      expect(actual[0].url).toEqual("#".concat(input[0].anchor));
    });
  });
  describe('formatUrl', function () {
    it('concatenates url and anchor', function () {
      // Given
      var input = {
        url: 'url',
        anchor: 'anchor'
      };

      // When
      var actual = _DocsSearchBar.default.formatURL(input);

      // Then
      expect(actual).toEqual('url#anchor');
    });
    it('returns only the url if no anchor', function () {
      // Given
      var input = {
        url: 'url'
      };

      // When
      var actual = _DocsSearchBar.default.formatURL(input);

      // Then
      expect(actual).toEqual('url');
    });
    it('returns the anchor if no url', function () {
      // Given
      var input = {
        anchor: 'anchor'
      };

      // When
      var actual = _DocsSearchBar.default.formatURL(input);

      // Then
      expect(actual).toEqual('#anchor');
    });
    it('does not concatenate if already an anchor', function () {
      // Given
      var input = {
        url: 'url#anchor',
        anchor: 'anotheranchor'
      };

      // When
      var actual = _DocsSearchBar.default.formatURL(input);

      // Then
      expect(actual).toEqual('url#anchor');
    });
    it('returns null if no anchor nor url', function () {
      // Given
      var input = {};

      // When
      var actual = _DocsSearchBar.default.formatURL(input);

      // Then
      expect(actual).toEqual(null);
    });
    it('emits a warning if no anchor nor url', function () {
      // Given
      var input = {};

      // When
      _DocsSearchBar.default.formatURL(input);

      // Then
      expect(window.console.warn.calledOnce).toBe(true);
    });
  });
  describe('getSuggestionTemplate', function () {
    it('should return a function', function () {
      // Given

      // When
      var actual = _DocsSearchBar.default.getSuggestionTemplate();

      // Then
      expect(actual).toBeInstanceOf(Function);
    });
  });
});